package output

import (
	"fmt"
	"os"
	"path/filepath"
	"time"
)

// OutputManager handles unified output structure for all analysis types
type OutputManager struct {
	ProjectName string
	OutputRoot  string
}

// OutputPaths contains all output paths for a project
type OutputPaths struct {
	ProjectRoot      string
	NetworkDiagrams  string
	IEC62443Diagrams string
	FirewallAnalysis string
	CombinedAnalysis string
	DataOutput       string
}

// NewOutputManager creates a new output manager
func NewOutputManager(projectName string) *OutputManager {
	if projectName == "" {
		projectName = fmt.Sprintf("analysis_%s", time.Now().Format("20060102_150405"))
	}

	return &OutputManager{
		ProjectName: projectName,
		OutputRoot:  "output",
	}
}

// SetOutputRoot allows customizing the root output directory
func (om *OutputManager) SetOutputRoot(root string) {
	om.OutputRoot = root
}

// CreateProjectStructure creates the unified directory structure
func (om *OutputManager) CreateProjectStructure() (*OutputPaths, error) {
	paths := &OutputPaths{
		ProjectRoot:      filepath.Join(om.OutputRoot, om.ProjectName),
		NetworkDiagrams:  filepath.Join(om.OutputRoot, om.ProjectName, "network_diagrams"),
		IEC62443Diagrams: filepath.Join(om.OutputRoot, om.ProjectName, "iec62443_diagrams"),
		FirewallAnalysis: filepath.Join(om.OutputRoot, om.ProjectName, "firewall_analysis"),
		CombinedAnalysis: filepath.Join(om.OutputRoot, om.ProjectName, "combined_analysis"),
		DataOutput:       filepath.Join(om.OutputRoot, om.ProjectName, "data"),
	}

	// Create all directories
	dirs := []string{
		paths.ProjectRoot,
		paths.NetworkDiagrams,
		paths.IEC62443Diagrams,
		paths.FirewallAnalysis,
		paths.CombinedAnalysis,
		paths.DataOutput,
	}

	for _, dir := range dirs {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return nil, fmt.Errorf("failed to create directory %s: %v", dir, err)
		}
	}

	return paths, nil
}

// GetProjectPaths returns the output paths for an existing project
func (om *OutputManager) GetProjectPaths() *OutputPaths {
	return &OutputPaths{
		ProjectRoot:      filepath.Join(om.OutputRoot, om.ProjectName),
		NetworkDiagrams:  filepath.Join(om.OutputRoot, om.ProjectName, "network_diagrams"),
		IEC62443Diagrams: filepath.Join(om.OutputRoot, om.ProjectName, "iec62443_diagrams"),
		FirewallAnalysis: filepath.Join(om.OutputRoot, om.ProjectName, "firewall_analysis"),
		CombinedAnalysis: filepath.Join(om.OutputRoot, om.ProjectName, "combined_analysis"),
		DataOutput:       filepath.Join(om.OutputRoot, om.ProjectName, "data"),
	}
}

// GenerateProjectSummary creates a summary file for the project
func (om *OutputManager) GenerateProjectSummary(paths *OutputPaths, metadata ProjectMetadata) error {
	summaryPath := filepath.Join(paths.ProjectRoot, "project_summary.md")

	content := fmt.Sprintf(`# %s - Project Summary

**Generated**: %s  
**Analysis Type**: %s  
**Input Sources**: %d

## Project Structure

- **üìä Network Diagrams**: Traditional network topology views
- **üè≠ IEC 62443 Diagrams**: Zone and conduit compliance analysis  
- **üîí Firewall Analysis**: Security policy and rule analysis
- **üöÄ Combined Analysis**: Advanced policy compliance assessment
- **üíæ Data**: Raw analysis data in JSON format

## Input Sources

%s

## Analysis Summary

%s

---
*Generated by CIPgram - OT Network Segmentation Analysis Tool*
`,
		om.ProjectName,
		time.Now().Format("2006-01-02 15:04:05"),
		metadata.AnalysisType,
		len(metadata.InputSources),
		formatInputSources(metadata.InputSources),
		formatAnalysisSummary(metadata.Summary),
	)

	return os.WriteFile(summaryPath, []byte(content), 0644)
}

// ProjectMetadata contains information about the analysis project
type ProjectMetadata struct {
	AnalysisType string
	InputSources []InputSourceInfo
	Summary      AnalysisSummary
}

// InputSourceInfo describes an input source
type InputSourceInfo struct {
	Type        string
	Path        string
	Size        int64
	Description string
}

// AnalysisSummary contains high-level analysis results
type AnalysisSummary struct {
	AssetsFound     int
	NetworksFound   int
	PoliciesFound   int
	ViolationsFound int
	RiskLevel       string
}

// Helper functions for formatting

func formatInputSources(sources []InputSourceInfo) string {
	if len(sources) == 0 {
		return "*No input sources specified*"
	}

	result := ""
	for i, source := range sources {
		result += fmt.Sprintf("%d. **%s**: `%s` (%s)\n",
			i+1, source.Type, source.Path, source.Description)
	}
	return result
}

func formatAnalysisSummary(summary AnalysisSummary) string {
	return fmt.Sprintf(`- **Assets Discovered**: %d devices and systems
- **Network Segments**: %d identified networks  
- **Security Policies**: %d firewall rules analyzed
- **Policy Violations**: %d potential issues found
- **Overall Risk Level**: %s`,
		summary.AssetsFound,
		summary.NetworksFound,
		summary.PoliciesFound,
		summary.ViolationsFound,
		summary.RiskLevel,
	)
}
